@using Todo.Data
@using Todo.Views.TodoItem
@model Todo.Models.TodoLists.TodoListDetailViewmodel

@{
    ViewData["Title"] = $"List: {Model.Title}";
}

@inject ApplicationDbContext dbContext

<h2>@ViewData["Title"]</h2>

<div class="col-md-6">

    <div>
        @Html.HiddenFor(m => m.TodoListId)
        @Html.Label("order-by-dropdown", "Order by: ")
        @Html.DropDownList(
            "order-by-dropdown",
            new List<SelectListItem>
            {
                new SelectListItem { Text = "Importance", Value = "Importance", Selected = !Model.OrderByRank },
                new SelectListItem { Text = "Rank", Value = "Rank", Selected = Model.OrderByRank }
            })
    </div>

    @Html.Label("hide-completed-items-checkbox", " Hide completed items")
    @Html.CheckBox("hide-completed-items-checkbox")

    <ul id="todo-list" class="list-group">

        @foreach (var item in Model.Items)
        {
            // Using Html.RenderPartialAsync() rather than Html.PartialAsync() here because it's more performant
            await Html.RenderPartialAsync("_TodoItemPartial.cshtml", item);
        }

    </ul>
</div>

<div class="col-md-4">

    <div class="form-group">
        @Html.Label("item-title", "Title")
        <input id="item-title" type="text" class="form-control" />
    </div>

    <div class="form-group">
        @Html.Label("importance", "Importance")
        @Html.DropDownList(
            "importance",
            SelectListConvenience.ImportanceSelectListItems,
            new { @class = "form-control" }
            )
    </div>

    <div class="form-group">
        @Html.Label("email-dropdown", "Email Address")
        @Html.DropDownList(
            "email-dropdown",
            dbContext.UserSelectListItems(),
            new { @class = "form-control" }
            )
    </div>

    <div class="form-group">
        <input id="add-item" type="button" class="btn btn-default" value="Add item">
    </div>

</div>

<script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
<script>
    var orderByRank = "@Model.OrderByRank".toLowerCase() === "true";
    if (orderByRank) {
        $("#todo-list").sortable({
            update: function () {
                var rank = 1;
                var newItemRanks = [];
                $('[id^="item-id"]').each(function () {
                    newItemRanks.push({ id: $(this).val(), rank });
                    rank++;
                });

                $.ajax({
                    url: '/TodoList/@Model.TodoListId',
                    method: 'POST',
                    contentType: 'application/json',
                    data: JSON.stringify({ newItemRanks })
                })
            }
        });
    }

    $("#add-item").click(function () {
        var todoItem = {};
        todoItem.todoListId = $("#TodoListId").val();
        todoItem.title = $("#item-title").val();
        todoItem.responsiblePartyId = $("#email-dropdown").val();
        todoItem.importance = $("#importance").val();

        $.ajax({
            url: '/TodoItem/CreateTodoItem',
            method: 'POST',
            contentType: 'application/json',
            data: JSON.stringify(todoItem)
        }).done(function () {
            // Note: The requirement for task 10 is that it should add a new item without navigating away from the detail page, I wasn't sure whether that meant it shouldn't
            // navigate to a different page or whether it meant it shouldn't reload the page at all. If the requirement is to have it add a new item to the list without
            // reloading the page then this functionality could be enhanced to append a new list item <li> to the <ul> list without reloading by using $("#todo-list").append()
            // The html for the new item could be generated by the API and returned. The old way of doing this would be to use Html.Action() and generate the
            // html from the _TodoItemPartial.cshtml partial view. The newer way of doing this would be to use a ViewComponent.
            location.reload();
        });
    });
</script>
